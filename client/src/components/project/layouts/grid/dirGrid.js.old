

angular.module('mappr')
	.directive('grid', function() {
		"use strict";
		return {
			restrict: 'E',


			scope: {
				in: '=data',
				out: '=',
				delta: '=',
				status: '=',
				evt: '=',
				footerPanels: '=',
				layout: '=',
				legend: '='
			},

			template: '<div id="grid-container" ng-class="layout.plotType == '+"'scatter' ? 'has-y' : ''"+'">'+
					'<div class="grid-holder">'+
					'<div class="grid-close" ng-show="footerPanels.isGridOpen" ng-click="footerPanels.toggleGrid();">'+
					'<div class="semicircle">'+
					'<i class="fa fa-angle-down fa-3x"/>'+
					'</div>'+
					'</div>'+
					'<div class="resize-handle ui-resizable-handle ui-resizable-n"></div>'+
					'<div class="tabs">'+
					'<a class="btn btn-mini nodes-btn"><i class="fa fa-circle-o fa-fw"/><span>NODES</span><span class="legend-text"></span></a>'+
					'<a class="btn btn-mini edges-btn"><i class="fa fa-expand fa-fw"/><span>EDGES</span><span class="legend-text"></span></a>'+
					'</div>'+
					'<div class="head"></div>'+
					'<div class="spread-container" ng-show="footerPanels.isGridOpen">'+
					'<div id="nodes" class="spread-template"></div>'+
					'<div id="edges" class="spread-template"></div>'+
					'</div>'+
					'<div class="modal-backdrop" ng-click="attr.isEdit = false;" ng-show="attr.isEdit"></div><div class="modal attr-detail" ng-show="attr.isEdit"><attributeedit attr="attr"/><i class="icon-close" ng-click="attr.isEdit = false;"/></div>'+
					'</div>'+
					'</div>',

			controller: ['$scope', '$element', '$attrs', function($scope, $element, $attrs) {
							var $grid = $($element[0].childNodes[0].childNodes[0].childNodes[4]);
							var head = $element[0].childNodes[0].childNodes[0].childNodes[3];
							var ndEle = $element[0].childNodes[0].childNodes[0].childNodes[4].childNodes[0];
							var edEle = $element[0].childNodes[0].childNodes[0].childNodes[4].childNodes[1];
							var spreadData = {ndColumns:[], edColumns:[], ndData:[], edData:[]};
							var dataTab = "nodes";
							var $nodesDataBtn = $($element[0]).find('.nodes-btn');
							var $edgesDataBtn = $($element[0]).find('.edges-btn');
							//has to know when resizing, so it can rerender grid
							var $resizer = $grid.parent();
							//number of columns before beginning to list attributes as columns
							var nodeAttrInd = 9;
							var edgeAttrInd = 6;
			
							//scale to spread color by and size by by
							var legendScale = 10;
			
							//types of columns (attributes)
							var columnTypes = ['text', 'number', 'radio', 'checkbox', 'file', 'link'];
							
							var ndGrid, edGrid;
			
			
							//for editing attribute
							$scope.attr = {
								context:null,
								content:{
									id:null,
									name:null,
									type:null,
									values:null,
									min:null,
									max:null,
									options:null,
									visible:true
								},
								isDirty:false,
								isEdit:false
							};
			
			
							// Converts an RGB object to a hex string
							var rgb2hex = function(rgb) {
								if (typeof rgb !== "undefined" && rgb !== null && (rgb.length === 3)) {
									//console.log(rgb);
									var hex = [
										rgb[0].toString(16),
										rgb[1].toString(16),
										rgb[2].toString(16)
									];
									$.each(hex, function(nr, val) {
										if (val.length === 1) hex[nr] = '0' + val;
									});
									return '#' + hex.join('');
								} else {
									return '#000';
								}
							};
							// Converts a hex string to an RGB object
							var hex2rgb = function(hex) {
								hex = parseInt(((hex.indexOf('#') > -1) ? hex.substring(1) : hex), 16);
								var c = [];
								c.push(hex >> 16);
								c.push((hex & 0x00FF00) >> 8);
								c.push(hex & 0x0000FF);
								return c;
							};
				
							//DATA TRANSFORMS
							$scope.layer2Spread = function(lrData) {
								var nodecl = [];
								var edgecl = [];
								var nd = [];
								var ed = [];
								// console.log(lrData);
			
			
								//header menu
								var propertyColMenu = {
									menu:{
											items: [{
												iconImage: "",
												title: "Property",
												disabled: true
											}]
										}
								};
			
								//use for coloring rows
								function renderColor(cellNode, row, dataContext, colDef) {
									var $cN = $(cellNode);
									var node = ndGrid.getCellNode(row, 0);
									$(node)
										.append('<div class="color-swatch" style="background:'+dataContext.col+';"/>');
									$cN.parent().off('mousenter.color, mouseleave.color');
									$cN.parent().on('mouseenter.color', function() {
										$(this).css({
											backgroundColor:dataContext.col
										});
									});
									$cN.parent().on('mouseleave.color', function() {
										$(this).css({
											backgroundColor:'transparent'
										});
									});
			
								}
			
			
								// BOOLEAN EDITOR
							function TrueFalseSelectEditor(args) {
			
								var $select;
								var defaultValue;
								var scope = this;
			
								this.init = function() {
			
									$select = $("<SELECT tabIndex='0' class='editor-yesno'><OPTION value='true'>true</OPTION><OPTION value='false'>false</OPTION></SELECT>");
									$select.appendTo(args.container);
									$select.focus();
								};
			
								this.destroy = function() {
									$select.remove();
								};
			
								this.focus = function() {
									$select.focus();
								};
			
								this.loadValue = function(item) {
									$select.val((defaultValue = item[args.column.field]) ? "true" : "false");
									$select.select();
								};
			
								this.serializeValue = function() {
									return ($select.val() == "true");
								};
			
								this.applyValue = function(item, state) {
									item[args.column.field] = state;
								};
			
								this.isValueChanged = function() {
									return ($select.val() != defaultValue);
								};
			
								this.validate = function() {
									var val = $select.val();
									if (val != "true" && val != "false") {
										return {
											valid: false,
											msg: "Please Enter either true or false"
										};
									}
									return {
										valid: true,
										msg: null
									};
								};
			
								this.init();
							}
			
								//node columns
								nodecl[0] = {id:0, name: 'NodeID', field : 'id', sortable:true, editor: Slick.Editors.Text,header: propertyColMenu};
								nodecl[1] = {id:1, name: 'Label', field : 'label', sortable:true, editor: Slick.Editors.Text,header: propertyColMenu};
								nodecl[2] = {id:2, name: 'Size', field : 'size', sortable:true, editor: Slick.Editors.Text,header: propertyColMenu};
								nodecl[3] = {id:3, name: 'PosX', field : 'posX', sortable:true,editor: Slick.Editors.Text,header: propertyColMenu};
								nodecl[4] = {id:4, name: 'PosY', field : 'posY', sortable:true,editor: Slick.Editors.Text,header: propertyColMenu};
								nodecl[5] = {id:5, name: 'Color', field : 'col', sortable:true,editor: Slick.Editors.LongText,header: propertyColMenu, asyncPostRender:renderColor};
								nodecl[6] = {id:6, name: 'Visible', field : 'visible', sortable:true,editor: TrueFalseSelectEditor,header: propertyColMenu};
								nodecl[7] = {id:7, name: 'JitterX', field : 'jitterX', sortable:true,editor: Slick.Editors.Text,header: propertyColMenu};
								nodecl[8] = {id:8, name: 'JitterY', field : 'jitterY', sortable:true,editor: Slick.Editors.Text,header: propertyColMenu};
								
								//remove any attrs that are added programattically
								lrData.attrs = _.filter(lrData.attrs, function(attr) {
									return attr.title != 'nodeId';
								});
			
								//Change db schema for attrs title-> name
								_.each(lrData.attrs, function(attr,index) {
									var colId = nodeAttrInd+index;
			
									var hideTitle = "Hide Column";
									if (attr.visible === false) {
										hideTitle = "Show Column";
									}
									nodecl.push({
										id: colId,
										name: attr.title,
										field: attr.title,
										type: attr.type || "string",
										sortable: true,
										cardType: attr.cardType,
										cardOptions: attr.cardOptions,
										visible: attr.visible,
										headerCssClass: attr.visible ? '' : 'col-hidden',
										editor: Slick.Editors.Text, //change depending on card type
										header: {
											menu: {
												items: [{
													iconImage: "",
													title: "ID: [col" + colId + "]",
													disabled: true
												}, {
													iconImage: "../images/sort-asc.gif",
													title: "Properties",
													command: "set-prop"
												}, {
													title: hideTitle,
													command: "hide",
													tooltip: "Can't hide this column"
												}, {
													title: "Color By",
													command: "color-by",
													tooltip: ""
												}, {
													title: "Size By",
													command: "size-by",
													tooltip: ""
												}, {
													title: "Make Category",
													command: "mk-cat",
													tooltip: ""
												}, {
													title: "Insert Left",
													command: "add-col-lf",
													tooltip: ""
												}, {
													title: "Insert Right",
													command: "add-col-rt",
													tooltip: ""
												}, {
													title: "Delete Column",
													command: "del-col",
													tooltip: ""
												}]
											}
										}
									});
								});
			
								//nodes
								_.each(lrData.nodes, function(node){
									if (typeof node.id !== "undefined") {
										var x_node = {};
										x_node.id = node.id;
										x_node.label = node.label;
										x_node.size = node.size;
										x_node.posX = node.posX;
										x_node.posY = node.posY;
										x_node.col = rgb2hex(node.col);
										x_node.visible = node.visible;
										x_node.jitterX = node.jitterX;
										x_node.jitterY = node.jitterY;
			
										_.each(node.attr, function(attr) {
											var column = _.find(nodecl, function(col) {
												return (parseInt(attr.id + nodeAttrInd) === parseInt(col.id));
											});
											if (column) x_node[column.field] = attr.val;
										});
			
										nd.push(x_node);
									}
								});
			
								//edge columns
								edgecl[0] = {id:0, name: 'EdgeID', field : 'id', sortable:true, editor: Slick.Editors.Text, header: propertyColMenu};
								edgecl[1] = {id:1, name: 'Label', field : 'label', sortable:true, editor: Slick.Editors.Text,header: propertyColMenu};
								edgecl[2] = {id:2, name: 'Source', field : 'source', sortable:true, editor: Slick.Editors.Text,header: propertyColMenu};
								edgecl[3] = {id:3, name: 'Target', field : 'target', sortable:true,editor: Slick.Editors.Text,header: propertyColMenu};
								edgecl[4] = {id:4, name: 'Color', field : 'col', sortable:true,editor: Slick.Editors.LongText,header: propertyColMenu, asyncPostRender:renderColor};
								edgecl[5] = {id:5, name: 'Visible', field : 'visible', sortable:true,editor: TrueFalseSelectEditor,header: propertyColMenu};
								//Change db schema for attrs title-> name
								_.each(lrData.edgeAttrs, function(attr,index) {
									var colId = edgeAttrInd+index;
									edgecl.push(
										{	id: colId,
											name: attr.title,
											field: attr.title,
											sortable:true,
											editor: Slick.Editors.Text,
											header :{
												menu: {
													items: [{
														iconImage: "",
														title: "ID: [col" + colId + "]",
														disabled: true
													},{
														iconImage: "/img/icons/slickgrid/sort-asc.gif",
														title: "Properties",
														command: "set-prop"
													}, {
														title: "Hide Column",
														command: "hide",
														tooltip: "Can't hide this column"
													}, {
														title: "Color By",
														command: "color-by",
														tooltip: ""
													}, {
														title: "Insert Left",
														command: "add-col-lf",
														tooltip: ""
													},{
														title: "Insert Right",
														command: "add-col-rt",
														tooltip: ""
													}, {
														title: "Delete Column",
														command: "del-col",
														tooltip: ""
													}]
												}
											}
										}
									);
								});
			
								//edges
								var ind = 0;
								_.each(lrData.edges, function(edge){
									//console.log('------e------');
									//console.log(edge);
									var x_edge = {};
									if(edge.id === null) {
										edge.id = ind;
									}
									ind++;
									x_edge.id = edge.id;
									x_edge.label = edge.label;
									x_edge.source = edge.source;
									x_edge.target = edge.target;
									x_edge.visible = edge.visible;
									//make sure color defined
									if (edge.col && edge.col !== null && edge.col.length === 3) {
										x_edge.col = rgb2hex(edge.col);
									}
									_.each(edge.attr, function(attr) {
										var column = _.find(edgecl, function(col){
											return Number(attr.id)+edgeAttrInd == col.id;
										});
										if(column) x_edge[column.field] = attr.val;
									});
									//console.log(x_edge);
									ed.push(x_edge);
								});
			
								return {ndColumns: nodecl, ndData: nd, edColumns: edgecl, edData: ed};
							};
			
							$scope.spread2layer = function() {
								console.log('spread2layer called');
								var layerData = {attrs:[], nodes:[], edgeAttrs:[], edges:[]};
			
								//write attrs
								//0-nodeAttrInd are properties
								var ndColumns = ndGrid.getColumns();
								for (var i = nodeAttrInd; i < ndColumns.length; i++) {
									layerData.attrs.push({
										id: i-nodeAttrInd,
										title: ndColumns[i].name,
										type: ndColumns[i].type,
										cardType: ndColumns[i].cardType,
										cardOptions:ndColumns[i].cardOptions,
										options: ndColumns[i].options,
										visible: ndColumns[i].visible
									});
								}
			
								//write nodes
								var ndData= ndGrid.getData();
								for (var j = 0; j < ndData.length; j++) {
									var attributes = [];
									for (var i = 0; i < layerData.attrs.length; i++) {
										//need to push i as id and not attr id to correctly reorder
										attributes.push({
											id: i,
											val: ndData[j][layerData.attrs[i].title]
										});
									}
									//console.log(attributes);
									//console.log(JSON.stringify(dataArr[j]));
									layerData.nodes.push({
										id: ndData[j].id,
										label: ndData[j].label,
										size: ndData[j].size,
										posX: ndData[j].posX,
										posY: ndData[j].posY,
										col: hex2rgb(ndData[j].col),
										visible:ndData[j].visible,
										jitterX: ndData[j].jitterX,
										jitterY: ndData[j].jitterY,
										attr: attributes
									});
								}
			
								//write attrs
								//0-edgeAttrInd are properties
								//for (var i = columns.length - 1; i >= 6; i--) { optimization possible!
								var edColumns = edGrid.getColumns();
								for (var i = edgeAttrInd; i < edColumns.length; i++) {
									layerData.edgeAttrs.push({
										id: i-edgeAttrInd,
										title: edColumns[i].name,
										type: edColumns[i].type,
										options: edColumns[i].options,
										visible: edColumns[i].visible
									});
								}
									// console.log(layerData.edgeAttrs);
			
								//write edges
								var edData = edGrid.getData();
								for (var j = 0; j < edData.length; j++) {
									var attributes = [];
									for (var i = 0; i < layerData.edgeAttrs.length; i++) {
										//need to push i as id and not attr id to correctly reorder
										attributes.push({
											id: i,
											val: edData[j][layerData.edgeAttrs[i].title]
										});
									}
									//console.log(JSON.stringify(dataArr[j]));
									var obj = {
										id: edData[j].id,
										label: edData[j].label,
										source: edData[j].source,
										target: edData[j].target,
										attr: attributes
									};
									if(edData[j].col && edData[j].col !== null && edData[j].col !== "") {
										obj.col = hex2rgb(edData[j].col);
									}
									layerData.edges.push(obj);
								}
								console.debug('layerData', layerData);
								return layerData;
							};
			
							var makegrid = function (gridType, ele, data, columns) {
			
								var grid;
								var type = gridType; //node or edge
			
								//needed for highlighting rows & cols only when cell is changed
								var currentCell = -1;
								var currentRow = -1;
			
			
								//OPTIONs
								var options = {
									enableCellNavigation: true,
									enableColumnReorder: true,
									//multiColumnSort: true,
									enableAddRow: true,
									asyncEditorLoading: false,
									editable: true,
									autoEdit: false,
									enableAsyncPostRender: true
									//showHeaderRow : false
								};
			
								//DATAVIEW
								//var dataView = new Slick.Data.DataView({ inlineFilters: true });
			
			
								// CELL FORMATTER
			
								function FormulaEditor(args) {
									var _self = this;
									var _editor = new Slick.Editors.Text(args);
									var _selector;
			
									$.extend(this, _editor);
			
									function init() {
										// register a plugin to select a range and append it to the textbox
										// since events are fired in reverse order (most recently added are executed first),
										// this will override other plugins like moverows or selection model and will
										// not require the grid to not be in the edit mode
										_selector = new Slick.CellRangeSelector();
										_selector.onCellRangeSelected.subscribe(_self.handleCellRangeSelected);
										args.grid.registerPlugin(_selector);
			
									}
			
									this.destroy = function() {
										_selector.onCellRangeSelected.unsubscribe(_self.handleCellRangeSelected);
										grid.unregisterPlugin(_selector);
										_editor.destroy();
									};
			
									this.handleCellRangeSelected = function(e, args) {
										_editor.setValue(
											_editor.getValue() +
											grid.getColumns()[args.range.fromCell].name +
											args.range.fromRow +
											":" +
											grid.getColumns()[args.range.toCell].name +
											args.range.toRow
										);
									};
			
									init();
								}
			
			
			
								//GRID
								grid = new Slick.Grid(ele, data, columns, options);
								grid.getCanvasNode().focus();
								grid.setSelectionModel(new Slick.CellSelectionModel());
			
								// dataView.setItems(data);
								// console.log('-- data view --');
			
								//CALLBACKS
								grid.onAddNewRow.subscribe(function(e, args) {
									// console.log('new row');
									var item = args.item;
									var column = args.column;
									grid.invalidateRow(data.length);
									data.push(item);
									grid.updateRowCount();
									grid.render();
									$scope.out.content = $scope.spread2layer();
									$scope.out.isDirty = true;
									//$scope.delta.content = {args.item}
									//$scope.status.msg = "saving data...";
									$scope.$apply();
								});
								grid.onSelectedRowsChanged.subscribe(function(e, args) {
									//console.log(grid.getSelectedRows());
								});
								grid.onColumnsReordered.subscribe(function(e, args) {
									console.log('columns reordered');
									$scope.out.content = $scope.spread2layer();
									$scope.out.isDirty = true;
									$scope.$apply();
								});
								grid.onCellChange.subscribe(function(e, args) {
									console.log("[spreadsheet] cellchange - broadcasting delta");
									//$scope.out.content = $scope.spread2layer();
									//$scope.out.isDirty = true;
			
									//
									// args : {row: 1, cell: 6, item: Object, grid: SlickGrid}
			
									// content: 
									// {
									//	action: 'node-update',
									//	"row": "0",
									//	"attr": "label",
									//	"value": "hickory"
									// }
									var at = (grid.getColumns())[args.cell].field;
									var val = (at === 'col') ? hex2rgb(args.item[at]) : args.item[at];
			
									var node = grid.getCellNode(args.row, grid.getColumnIndex(0));
									var nodeId = $(node).text();
									$scope.delta.content = {action: gridType+"-update", row: nodeId, attr: at, value:val};
									$scope.delta.source = 'spreadsheet';
									$scope.delta.isDirty = true;
			
									console.log($scope.delta.content);
			
									//$scope.status.msg = "[spreadsheet] broadcasting delta...";
									$scope.$apply();
								});
			
								// $scope.spreadDelta2layer = function(delta){
								//	//row update -> node / edge update
								//	//delta content {row: 1, cell: 6, item: row}
								// }
			
								//http://jsfiddle.net/hXECL/3/
								var makeActiveCellEditableSwitch = true;
			
								grid.onKeyDown.subscribe(function(e, handler) {
										if (e.which == 90 && (e.ctrlKey || e.metaKey)) { // CTRL + (shift) + z
											if (e.shiftKey) {
												undoRedoBuffer.redo();
											} else {
												undoRedoBuffer.undo();
											}
										} else if (e.which == 37) { //left
											makeActiveCellEditableSwitch = true;
										} else if (e.which == 39) { //right
											makeActiveCellEditableSwitch = true;
										} else if (e.which == 38) { //up
											makeActiveCellEditableSwitch = true;
										} else if (e.which == 40) { //down
											makeActiveCellEditableSwitch = true;
										} else if (e.which == 9) { //tab
											makeActiveCellEditableSwitch = true;
										} else if (e.which == 13) { //enter
											data = grid.getData();
											columns = grid.getColumns();
											if(grid.getActiveCell().row == grid.getData().length) {
												var x_node = {};
												_.each(columns, function(col) {
													x_node[col.field] = "";
												});
												data.push(x_node);
												grid.updateRowCount();
												grid.render();
											}
											//grid.navigateDown();
											makeActiveCellEditableSwitch = true;
										} else if (e.which == 27) { //esc
											makeActiveCellEditableSwitch = true;
											grid.resetActiveCell();
										} else if (e.which == 8) { //backspace
											var $inp = $(grid.getActiveCellNode()).find('input');	
											if($inp.is(':focus')) {
												return;
											}
											console.log('firing backspace');
											makeActiveCellEditableSwitch = true;
											$inp.val('');
											grid.editActiveCell();
										} else if(!(e.ctrlKey || e.metaKey)) {
											var $inp = $(grid.getActiveCellNode()).find('input');	
											if($inp.is(':focus')) {
												return;
											}
											//return;
											//this breaks the edit cell capabilities by 
											//not appending to cell and rewriting contents
											//on keypress
											if (makeActiveCellEditableSwitch ) {
												grid.editActiveCell(Slick.Editors.Text);
												makeActiveCellEditableSwitch = false;
											}
										}
								});
			
								//set column highlight for current cell
								grid.onActiveCellChanged.subscribe(function(e, handler) {
									if(handler.row) {
										var cell = handler.cell;
										if(currentCell == cell) {
											return;
										}
										var cols = grid.getColumns();
										var col = cols[cell];
										for(var i = cols.length-1; i > -1; i--) {
											cols[i].cssClass = "";
											cols[i].headerCssClass = "";
										}
										cols[col.id].cssClass = "col-active";
										cols[col.id].headerCssClass = "col-active";
										grid.setColumns(cols);
										currentCell = cell;
									}
								});
			
			
								grid.onClick.subscribe(function(e, handler) {
									makeActiveCellEditableSwitch = true;
									var targetCell = grid.getCellFromEvent(e);
									var cols = grid.getColumns();
									var col = cols[targetCell.cell];
									var attr = col.field;
									var node = grid.getCellNode(targetCell.row, grid.getColumnIndex(0));
									var nodeId = $(node).text();
									$scope.evt.content = {action: 'click', row: nodeId, attr: attr};
									$scope.evt.source = 'spreadsheet';
									$scope.evt.context = dataTab;
									//$scope.evt.notify();
									$scope.$apply();
								});
			
								grid.onDblClick.subscribe(function(e, handler) {
									//console.log('dblclick');
									makeActiveCellEditableSwitch = true;
									var targetCell = grid.getCellFromEvent(e);
									var col = grid.getColumns()[targetCell.cell];
									var attr = col.field;
									var node = grid.getCellNode(targetCell.row, grid.getColumnIndex(0));
									var nodeId = $(node).text();
									$scope.evt.content = {action: 'dblclick', row: nodeId, attr: attr};
									$scope.evt.source = 'spreadsheet';
									$scope.evt.context = dataTab;
									//$scope.evt.notify();
									$scope.$apply();
								});
			
								grid.onSort.subscribe(function(e, args) {
									console.log('sort');
									var sortcol = args.sortCol.field;
									var isNumber = function(n) {
										return !isNaN(parseFloat(n)) && isFinite(n);
									};
									var data = grid.getData();
									data.sort(function comparer(a, b) {
										var x = a[sortcol],
											y = b[sortcol];
										if (isNumber(x) && isNumber(y)) {
											x = parseFloat(x);
											y = parseFloat(y);
										}
										return args.sortAsc ? (x == y ? 0 : (x < y ? 1 : -1)) : (x == y ? 0 : (x > y ? 1 : -1));
									});
									grid.invalidate();
									grid.render();
								});
			
								grid.onBeforeEditCell.subscribe(function(e, args) {
			
									// if (!isCellEditable(args.row, args.cell, args.item)) {
									//	return false;
									//}
			
									// if (args.row === 4) {
									//	return false;
									//  }
								});
			
								function overEvent(row) {
									// var r = dataView.getItems();
									// console.log(r);
								}
			
			
								grid.onMouseEnter.subscribe(function(e, args) {
									var targetCell = grid.getCellFromEvent(e);
									//overEvent(targetCell.row);
									var targetCell = grid.getCellFromEvent(e);
									var attr = grid.getColumns()[targetCell.cell].field;
									var $node = $(grid.getCellNode(targetCell.row, grid.getColumnIndex(0)));
									var nodeId = $node.text();
									$scope.evt.content = {action: 'mouseenter', row: nodeId, attr: attr};
									$scope.evt.source = 'spreadsheet';
									$scope.evt.context = dataTab;
									//$scope.evt.notify();
									//$scope.$apply();
			
									//console.log($scope.evt.content);
									//console.log(grid.getCellFromEvent(e));
			
								});
			
								grid.onMouseLeave.subscribe(function(e, args) {
									var targetCell = grid.getCellFromEvent(e);
									var col = grid.getColumns()[targetCell.cell];
									var attr = col.field;
									var node = grid.getCellNode(targetCell.row, grid.getColumnIndex(0));
									var nodeId = $(node).text();
									$scope.evt.content = {action: 'mouseleave', row: nodeId, attr: attr};
									$scope.evt.source = 'spreadsheet';
									$scope.evt.context = dataTab;
									//$scope.evt.notify();
									//$scope.$apply();
									//console.log($scope.evt.content);
									//console.log(grid.getCellFromEvent(e));
									//add class to column and row
			
								});
			
			
								//for scrolling when dragging to select cells
								var $spreadContainer = $('.spread-container');
								var isMouseDown = false;
								// need to use pure js so can grab at capture phase since cell range selector stopping event propogation
								$spreadContainer.get(0).addEventListener('mousedown', function(e, args){ 
									isMouseDown = true;
								}, true);
			
								// need to use pure js so can grab at capture phase since cell range selector stopping event propogation
								$spreadContainer.get(0).addEventListener('mouseup', function(e, args) {
									isMouseDown = false;
								}, true)
			
								$spreadContainer.on('mousemove', function(e){ //#myGrid is id of div of grid container
									if(isMouseDown) {
										var parentOffset = $(this).offset(); 
										var diffX = ( ( parentOffset.left + $spreadContainer.width() ) - e.pageX);
										var diffY = ( ( parentOffset.top + $spreadContainer.height() ) - e.pageY);
										if (diffX < 59 && diffX > 17){ //change the minimum and maximum area where you want to scroll. mine requirement is 59 and 17. You can find your custom position by some alerting or console.log
											$('.slick-viewport').scrollLeft($('.slick-viewport ').scrollLeft() + 10);
										}
										if (diffY < 100 && diffY > 17){ //change the minimum and maximum area where you want to scroll. mine requirement is 59 and 17. You can find your custom position by some alerting or console.log
											$('.slick-viewport').scrollTop($('.slick-viewport ').scrollTop() + 10);
										}	
									}
								});
			
								
			
								//UNDO REDO PLUGIN
								var undoRedoBuffer = {
									commandQueue: [],
									commandCtr: 0,
			
									queueAndExecuteCommand: function(editCommand) {
										this.commandQueue[this.commandCtr] = editCommand;
										this.commandCtr++;
										editCommand.execute();
									},
			
									undo: function() {
										if (this.commandCtr === 0)
											return;
			
										this.commandCtr--;
										var command = this.commandQueue[this.commandCtr];
			
										if (command && Slick.GlobalEditorLock.cancelCurrentEdit()) {
											command.undo();
										}
									},
									redo: function() {
										if (this.commandCtr >= this.commandQueue.length)
											return;
										var command = this.commandQueue[this.commandCtr];
										this.commandCtr++;
										if (command && Slick.GlobalEditorLock.cancelCurrentEdit()) {
											command.execute();
										}
									}
								};
								var pluginOptions = {
									clipboardCommandHandler: function(editCommand) {
										undoRedoBuffer.queueAndExecuteCommand.call(undoRedoBuffer, editCommand);
									},
									addColumn:function(args) {
										var columns = grid.getColumns();
										var newColId = args.column.id + 1;
										columns.splice(newColId, 0, {
											id: newColId,
											name: 'New Attrib',
											field: 'col' + newColId,
											sortable: true,
											editor: Slick.Editors.Text
										});
										//update
										columns[newColId].header = {
											menu: {
												items: [{
													title: "ID: [col" + columns[newColId].id + "]",
													disabled: true
												}, {
													iconImage: "../images/sort-asc.gif",
													title: "Properties",
													command: "set-prop"
												}, {
													title: "Hide Column",
													command: "hide",
													tooltip: "Can't hide this column"
												}, {
													title: "Color By",
													command: "color-by",
													tooltip: ""
												}, {
													title: "Size By",
													command: "size-by",
													tooltip: ""
												}, {
													title: "Make Category",
													command: "mk-cat",
													tooltip: ""
												}, {
													title: "Insert Left",
													command: "add-col-lf",
													tooltip: ""
												}, {
													title: "Insert Right",
													command: "add-col-rt",
													tooltip: ""
												}, {
													title: "Delete Column",
													command: "del-col",
													tooltip: ""
												}]
											}
										};
										for (var i = columns.length - 1; i > newColId; i--) {
											columns[i].id = i;
											columns[i].header.menu.items[0].title = "Col ID:" + columns[i].id;
										}
										grid.setColumns(columns);
										grid.render();
									}
								};
								var CellExternalCopyPlugin = new Slick.CellExternalCopyManager(pluginOptions);
								CellExternalCopyPlugin.onPasteCells.subscribe(function(e, args) {
									console.log('paste');
									$scope.out.content = $scope.spread2layer();
									$scope.out.isDirty = true;
									//$scope.status.msg = "saving data...";
									$scope.$apply();
								});
								grid.registerPlugin(CellExternalCopyPlugin);
			
								//HEADER MENU PLUGIN
								var headerMenuPlugin = new Slick.Plugins.HeaderMenu({});
								headerMenuPlugin.onBeforeMenuShow.subscribe(function(e, args) {
									var menu = args.menu;
									// We can add or modify the menu here, or cancel it by returning false.
									// var i = menu.items.length;
									// menu.items.push({
									//	title: "Menu item " + i,
									//	command: "item" + i
									// });
								});
								headerMenuPlugin.onCommand.subscribe(function(e, args) {
									switch (args.command) {
										case 'add-col-lf':
											var columns = grid.getColumns();
											var newColId = args.column.id;
											columns.splice(newColId, 0, {
												id: newColId,
												name: 'New Attrib '+columns.length,
												field: 'col' + newColId,
												sortable: true,
												editor: Slick.Editors.Text
											});
											var hideTitle = "Hide Column";
											if(columns[newColId].visible === false) {
												hideTitle = "Show Column";
											}
											//update
											columns[newColId].header = {
												menu: {
													items: [{
														title: "ID: [col" + columns[newColId].id + "]",
														disabled: true
													}, {
														iconImage: "../images/sort-asc.gif",
														title: "Properties",
														command: "set-prop"
													}, {
														title: hideTitle,
														command: "hide",
														tooltip: "Can't hide this column"
													}, {
														title: "Make Category",
														command: "mk-cat",
														tooltip: ""
													}, {
														title: "Insert Left",
														command: "add-col-lf",
														tooltip: ""
													}, {
														title: "Insert Right",
														command: "add-col-rt",
														tooltip: ""
													}, {
														title: "Delete Column",
														command: "del-col",
														tooltip: ""
													}]
												}
											};
											for (var i = columns.length - 1; i > newColId; i--) {
												columns[i].id = i;
												columns[i].header.menu.items[0].title = "Col ID:" + columns[i].id;
											}
											grid.setColumns(columns);
											grid.render();
											break;
										case 'add-col-rt':
											var columns = grid.getColumns();
											var newColId = args.column.id + 1;
											console.log('newcolid: '+newColId);
											columns.splice(newColId, 0, {
												id: newColId,
												name: 'New Attrib '+columns.length,
												field: 'col' + newColId,
												sortable: true,
												editor: Slick.Editors.Text
											});
											//update
											columns[newColId].header = {
												menu: {
													items: [{
														title: "ID: [col" + columns[newColId].id + "]",
														disabled: true
													}, {
														iconImage: "../images/sort-asc.gif",
														title: "Properties",
														command: "set-prop"
													}, {
														title: "Hide Column",
														command: "hide",
														tooltip: "Can't hide this column"
													}, {
														title: "Make Category",
														command: "mk-cat",
														tooltip: ""
													}, {
														title: "Insert Left",
														command: "add-col-lf",
														tooltip: ""
													}, {
														title: "Insert Right",
														command: "add-col-rt",
														tooltip: ""
													}, {
														title: "Delete Column",
														command: "del-col",
														tooltip: ""
													}]
												}
											};
											for (var i = columns.length - 1; i > newColId; i--) {
												columns[i].id = i;
												if(columns[i].header.menu) {
													columns[i].header.menu.items[0].title = "Col ID:" + columns[i].id;
												}
											}
											grid.setColumns(columns);
											grid.render();
											break;
										case 'del-col':
											var columns = grid.getColumns();
											var newColId = args.column.id;
											columns.splice(newColId, 1);
											for (var i = columns.length - 1; i >= newColId; i--) {
												columns[i].id = i;
												columns[i].header.menu.items[0].title = "Col ID:" + columns[i].id;
											}
											grid.setColumns(columns);
											grid.render();
											break;
										case 'set-prop':
											var columns = grid.getColumns();
											var data = grid.getData();
											var min;
											var max;
											var values = [];
											_.each(data, function(at) {
												var val = at[args.column.name];
												// console.log(val);
												//push values into values array
												values.push(val);
												//check if number and if so, get min and max
												if(!isNaN(val)) {
													if(min === undefined) {
														min = val;
														max = val;
													} else {
														min = Math.min(val, min);
														max = Math.max(val, max);
													}
												}
											});
											//check column type against our own types
											//if not one, then determine if string or text
											var colType = args.column.type;
											if(columnTypes.indexOf(colType) == -1) {
												if(min) {
													colType = "number";
												} else {
													colType = "string";
												}
											}
											var attrId = args.column.id;
											if(gridType == 'node') {
												attrId-=nodeAttrInd;
											} else {
												attrId-=edgeAttrInd;
											}
											$scope.attr = {
												context:gridType, //node or edge
												content:{
													id:attrId,
													name:args.column.name,
													type:args.column.type,
													cardType:args.column.cardType,
													cardOptions:args.column.cardOptions,
													values:values,
													min:min,
													max:max,
													visible:args.column.visible
												},
												isDirty:false, //don't set to dirty until you want to save
												isEdit:true
											};
											$scope.$apply();
			
											break;
										case 'hide':
			
											var columns = grid.getColumns();
											var newColId = args.column.id;
											var column = columns[newColId];
											column.visible = !column.visible;
											//set column menu to show
											if(column.visible) {
												column.header.menu.items[2].title = "Hide Column";
												column.headerCssClass = "";
											} else {
												column.header.menu.items[2].title = "Show Column";
												column.headerCssClass = "col-hidden";
											}
											columns[newColId] = column;
											grid.setColumns(columns);
			
											break;
										case 'color-by':
											var columns = grid.getColumns();
											var data = grid.getData();
											var min;
											var max;
											var legendType;
											var values = [];
											var colors = [];
											var totals = [];
											var attrName = args.column.name; 
											//to check if string
											var isString = false;
											_.each(data, function(at) {
												var val = at[attrName];
												// console.log(val);
												//push values into values array
												// values.push(val);
												//check if number and if so, get min and max
												if(!isNaN(val) && isFinite(val)) {
													if(min === undefined) {
														min = val;
														max = val;
													} else {
														min = Math.min(val, min);
														max = Math.max(val, max);
													}
												} else {
													isString = true;
												}
												// throw into array to categorize
												if(values.indexOf(val) == -1) {
													values.push(val);
												}
											});
											//set up rainbow for getting colors
											var rainbow = new Rainbow();
											//if category, use spectrum
											rainbow.setSpectrum('ee4444', 'cc6600', '0099ff', 'ffcc00', '66cccc', '99cc00', '993399');
											//is category
											if(isString) {
												//sort values alphabetically
												values.sort();
												//if values are strings, then legend type is category
												legendType = 'category';
												//set up totals array as length of categories and assign zero
												for (var i = values.length - 1; i >= 0; i--) {
													totals.push(0);
												}
												//if only one value, set all to red
												if(values.length == 1) {
													_.each(data, function(at) {
														at.col = '#ff0000';
														totals[0]++;
													});
													colors = ['ff0000'];
												} else {
													rainbow.setNumberRange(1, values.length);
													var tot = values.length;
													_.each(data, function(at) {
														var val = at[attrName];
														var num = values.indexOf(val)+1;
														//fucking brits
														at.col = rainbow.colourAt(num);
														colors[num-1] = at.col;
														totals[num-1]++;
													});
												}
											} else {
												//if values are numbers, then legend type is gradient
												legendType = 'gradient';
												totals.push(0);
												//if only one value, set all to red
												if(values.length == 1) {
													_.each(data, function(at) {
														at.col = '#ff0000';
														totals[0]++;
													});
													colors = ['ff0000'];
												} else {
													rainbow.setNumberRange(min, max);
													//if number, set gradient between 2 colors
													rainbow.setSpectrum('ee4444', '3399ff');
													var rat = legendScale/(max - min);
													_.each(data, function(at) {
														var val = at[attrName];
														//fucking brits
														at.col = rainbow.colourAt(val);
														//just push total into first since gradient
														totals[0]++;
													});
													values = [min, max];
													colors = ['ee4444', '3399ff'];
												}
											}
											//get total (edges or nodes)
											var tot = _.reduce(totals, function(sum, num) {
												return sum + num;
											});
											$scope.legend.source = 'spreadsheet';
											if(dataTab == "nodes") {
												//set legend based on values and colors
												$scope.legend.nodes.title = "NODES "+tot;
												$scope.legend.nodes.color = {
													type: legendType,
													colors: colors,
													values: values,
													labels: values,
													totals: totals,
													attr: attrName
												};
											} else {
												//set legend based on values and colors
												$scope.legend.edges.title = "EDGES "+tot;
												$scope.legend.edges.color = {
													type: legendType,
													colors: colors,
													values: values,
													labels: values,
													totals: totals,
													attr: attrName
												};
											}
											break;
										case 'size-by':
											var columns = grid.getColumns();
											var data = grid.getData();
											var min;
											var max;
											var legendType;
											var values = [];
											var sizes = [];
											var totals = [];
											var attrName = args.column.name;
											//to check if string
											var isString = false;
											_.each(data, function(at) {
												var val = at[attrName];
												// console.log(val);
												//push values into values array
												// values.push(val);
												//check if number and if so, get min and max
												if(!isNaN(val) && isFinite(val)) {
													if(min === undefined) {
														min = val;
														max = val;
													} else {
														min = Math.min(Number(val), min);
														max = Math.max(Number(val), max);
													}
												} else {
													isString = true;
												}
												// throw into array to categorize
												if(values.indexOf(val) == -1) {
													values.push(val);
												}
											});
											//loop through again to add size values
											// var size = (val - min) / (max - min) * 10;
											if(isString) {
												//sort values alphabetically
												values.sort();
												legendType = 'category';
			
												var tot = values.length;
												//set up totals array as length of categories and assign zero
												for (var i = values.length - 1; i >= 0; i--) {
													totals.push(0);
												}
												_.each(data, function(at) {
													var val = at[attrName];
													var ind = values.indexOf(val);
													//look for val in array and use to get ratio
													at.size = Number(((ind+1)/tot*legendScale)).toFixed(2);
													sizes[ind] = at.size;
													totals[ind]++;
												});
											} else {
												legendType = 'gradient';
												totals.push(0);
												var rat = legendScale/(max - min);
												_.each(data, function(at) {
													var val = at[attrName];
													//get ratio of number on a scale of 1-10
													at.size = Number((val - min) * rat).toFixed(2);
													totals[0]++;
												});
												values = [min, max];
												sizes = [1, 10];
											}
											ndGrid.setData(data, true);
			
											//get total (nodes)
											var tot = _.reduce(totals, function(sum, num) {
												return sum + num;
											});
											//set legend based on values and sizes
											$scope.legend.source = 'spreadsheet';
											$scope.legend.nodes.title = "NODES "+tot;
											$scope.legend.nodes.size = {
												type: legendType,
												sizes: sizes,
												values: values,
												labels: values,
												totals: totals,
												attr: attrName
											};
											break;
										default:
											alert("Command: " + args.command);
									}
									//don't set property save since doing in its own directive
									if(args.command != "set-prop") {
										$scope.out.content = $scope.spread2layer();
										$scope.out.isDirty = true;
										//$scope.status.msg = "saving data...";
										$scope.$apply();
									}
								});
			
								grid.registerPlugin(headerMenuPlugin);
			
								//for resizing container for grid
							//	$resizer.on('resize', function() {
							//		grid.resizeCanvas();
							//		console.log('resizing');
							//	})
							//var resize = function() {
							//	grid.resizeCanvas();
							//	console.log('resizing');
							// }
			
			
								return grid;
							};
			
							ndGrid = makegrid('node', ndEle, spreadData.ndData, spreadData.ndColumns);
							edGrid = makegrid('edge', edEle, spreadData.edData, spreadData.edColumns);
			
			
			
			
							//WATCH IN
							$scope.$watch('in', function(oldVal, newVal){
								if(newVal!=oldVal){
									console.log($scope.in);
									console.log('[spreadsheet] layer data change - updating spreadsheets');
									// ndGrid.gotoCell(0,0,false);
									// edGrid.gotoCell(0,0,false);
									spreadData = $scope.layer2Spread($scope.in.content);
									ndGrid.setColumns(spreadData.ndColumns);
									ndGrid.setData(spreadData.ndData, true);
									edGrid.setColumns(spreadData.edColumns);
									edGrid.setData(spreadData.edData, true);
			
									$nodesDataBtn.find('.legend-text').text(spreadData.ndData.length);
									$edgesDataBtn.find('.legend-text').text(spreadData.edData.length);
									$nodesDataBtn.addClass('active');
			
									if(dataTab == 'nodes') {
										ndGrid.render();
										$(edEle).hide();
										$(ndEle).show();
									} else {
										edGrid.render();
										$(ndEle).hide();
										$(edEle).show();
									}
								}
							}, true);
			
							//WATCH EVT
							$scope.$watch('evt', function(oldVal, newVal) {
								if(newVal != oldVal) {
									//console.log($scope.evt);
									if ($scope.evt.source !== 'spreadsheet') {
										var evtContent = $scope.evt.content;
										switch(evtContent.action) {
											case 'mouseenter':
												console.log('[spreadsheet] mouseenter from controller');
			
												break;
											case 'mouseleave':
												console.log('[spreadsheet] mouseleave from controller');
												break;
											default:
										}
									}
								}
							}, true);
			
							//WATCH DELTA
							$scope.$watch('delta', function(oldVal, newVal){
								if(newVal!=oldVal){
									//console.log($scope.delta);
									console.log('[spreadsheet] delta detected from ' + $scope.delta.source);
									if ($scope.delta.source != 'spreadsheet') {
										console.log('[spreadsheet] can update only if the bits behave');
										//only thing currently available
										switch ($scope.delta.content.action) {
											case 'node-update':
												//find row by id
												var ndData= ndGrid.getData();
												var n = _.findWhere(ndData,{id:$scope.delta.content.row});
												n[$scope.delta.content.attr] = $scope.delta.content.value;
												ndGrid.setData(ndData);
												ndGrid.render();
											break;
											default:
										}
									} else {
										console.log('[spreadsheet] ignoring delta..');
									}
								}
							}, true);
			
			
							//WATCH ATTR (FROM DIRATTREDIT)
							$scope.$watch('attr', function(oldVal, newVal) {
			
								//console.log($scope.attr);
								//change column name only if dirty (from save in modal)
								if(oldVal != newVal && $scope.attr.isDirty) {
									if($scope.attr.context == 'node') {
										ndGrid.updateColumnHeader($scope.attr.content.id+nodeAttrInd, $scope.attr.content.name);
										ndGrid.render();
									} else if($scope.attr.context == 'edge') {
										edGrid.updateColumnHeader($scope.attr.content.id+edgeAttrInd, $scope.attr.content.name);
										edGrid.render();
									}
									//if undefined, then set to default (string)
									if(!$scope.attr.content.type) {
										$scope.attr.content.type = "string";
									}
									//save via delta
									$scope.delta.content = {
										action: $scope.attr.context+'-attr-update',
										attr: $scope.attr.content.name,
										value: {
											type: $scope.attr.content.type,
											id: $scope.attr.content.id,
											cardOptions: $scope.attr.content.cardOptions,
											cardType: $scope.attr.content.cardType,
											visible: $scope.attr.content.visible
										}
									};
									// console.log($scope.delta.content);
									$scope.delta.source = 'spreadsheet';
									$scope.delta.isDirty = true;
			
									//hide modal
									$scope.attr.isDirty = false;
			
									//$scope.$apply();
								}
							}, true);
			
							//needed for resizing
							$scope.$watch('footerPanels', function(oldVal, newVal) {
								if(oldVal != newVal) {
									if($scope.rightPanels.isGridOpen) {
										$resizer.css({
											top: gridResizeTop,
											height: gridResizeHeight
										});
									} else {
										gridResizeTop = $resizer.css('top');
										gridResizeHeight = $resizer.height();
										$resizer.css({
											top: gridResizeTopOrig,
											height: gridResizeHeightOrig
										});
									}
									setTimeout(function() {
										ndGrid.resizeCanvas();
									},300);
								}
							}, true);
			
							var gridResizeTop = 50;
							var gridResizeHeight = $resizer.height();
							var gridResizeTopOrig = gridResizeTop;
							var gridResizeHeightOrig = gridResizeHeight;
			
							$resizer.resizable({
								handles: {
									n: '.resize-handle'
								},
								resize: function(e, ui) {
									ndGrid.resizeCanvas();
									edGrid.resizeCanvas();
								},
								stop: function(e, ui) {
									
									gridResizeTop = $resizer.css('top');
									gridResizeHeight = $resizer.height();
									ndGrid.resizeCanvas();
									edGrid.resizeCanvas();
								}
							});
			
			
			
							$nodesDataBtn.on('click', function(e) {
								console.log($scope.attr);
									dataTab = "nodes";
									e.stopPropagation();
									ndGrid.gotoCell(0,0,false);
									$(edEle).hide();
									$(ndEle).show();
									var $vp = $(ndEle).find('.slick-viewport');
									$vp.scrollTop($vp.scrollTop()+5);
									ndGrid.resizeCanvas();
									$(this).addClass('active');
									$edgesDataBtn.removeClass('active');
									$(this).css({
										zIndex:3
									});
									$edgesDataBtn.css({
										zIndex:2
									});
							});
			
							$edgesDataBtn.on('click', function(e) {
			
									dataTab = "edges";
									e.stopPropagation();
									edGrid.gotoCell(0,0,false);
									$(ndEle).hide();
									$(edEle).show();
									var $vp = $(edEle).find('.slick-viewport');
									$vp.scrollTop($vp.scrollTop()+5);
									edGrid.resizeCanvas();
									$(this).addClass('active');
									$nodesDataBtn.removeClass('active');
									$(this).css({
										zIndex:3
									});
									$nodesDataBtn.css({
										zIndex:2
									});
							});
						}]
		};
	});